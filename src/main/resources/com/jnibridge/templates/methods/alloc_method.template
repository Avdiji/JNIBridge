    JNIEXPORT void JNICALL ${mangledFuncName}(JNIEnv* env, jobject jself${jniParams})
    {
        // check whether jobject has already been allocated
        if (jnibridge::internal::getHandle(env, jself) != 0) return;

        // super-types allocate() function should not be executed
        bool canAlloc = env->IsSameObject(env->GetObjectClass(jself), env->FindClass("${fullJPath}"));
        if(!canAlloc) { return; }

        // input mappings...
${paramInMapping}

        // output mappings...
        ${cType}* newNativeObject = new ${cType}(${functionCallParams});
        auto newWrappedNativeObject = new jnibridge::internal::JniBridgePtrWrapper<${cType}>(newNativeObject, true);

        jnibridge::internal::setNativeHandle<${cType}>(env, jself, newWrappedNativeObject);
    }