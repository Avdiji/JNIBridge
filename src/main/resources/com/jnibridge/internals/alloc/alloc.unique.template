    JNIEXPORT void JNICALL ${mangledFuncName}(JNIEnv* env, jobject jself${jniParams})
    {
${nullcheck}

            std::vector<jthrowable> pendingJExceptions;

            // CONSTRUCTOR CHECKS
            if (jnibridge::internal::getHandle(env, jself) != 0) return;

            // super-types allocate() function should not be executed
            bool canAlloc = env->IsSameObject(env->GetObjectClass(jself), env->FindClass("${fullJPath}"));
            if(!canAlloc || jnibridge::internal::capturePendingJException(env, pendingJExceptions)) { return; }

${paramInMapping}

        try {
            // ALLOCATION
            auto uniqueNativeObject = std::make_unique<${cType}>(${functionCallParams});
            auto newHandle = new jnibridge::internal::Handle<${cType}>(std::move(uniqueNativeObject));
            auto newBaseHandle = static_cast<jnibridge::internal::BaseHandle*>(newHandle);
            jnibridge::internal::setNativeHandle(env, jself, newBaseHandle);

		    jnibridge::internal::capturePendingJException(env, pendingJExceptions);
		    goto cleanup;

        } catch (const std::exception &e) {
            jthrowable jexception = jnibridge::internal::handleException(env, e);
            env->Throw(jexception);
		    jnibridge::internal::capturePendingJException(env, pendingJExceptions);
		    goto cleanup;
        }
        cleanup:
${cleanup}
		    jnibridge::internal::capturePendingJException(env, pendingJExceptions);
		    jnibridge::internal::throwPendingJException(env, pendingJExceptions);
            return;
    }